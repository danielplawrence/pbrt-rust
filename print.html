<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>pbrt-rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Implementation notes for a physically-based renderer in Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="geometry_and_transformations.html"><strong aria-hidden="true">1.</strong> Geometry and Transformations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="geometry_vectors.html"><strong aria-hidden="true">1.1.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="geometry_points.html"><strong aria-hidden="true">1.2.</strong> Points</a></li><li class="chapter-item expanded "><a href="geometry_normals.html"><strong aria-hidden="true">1.3.</strong> Normals</a></li><li class="chapter-item expanded "><a href="geometry_rays.html"><strong aria-hidden="true">1.4.</strong> Rays</a></li><li class="chapter-item expanded "><a href="geometry_bounding_boxes.html"><strong aria-hidden="true">1.5.</strong> Bounding Boxes</a></li><li class="chapter-item expanded "><a href="geometry_transformations.html"><strong aria-hidden="true">1.6.</strong> Transformations</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">pbrt-rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pbrt-rust"><a class="header" href="#pbrt-rust">pbrt-rust</a></h1>
<p>pbrt-rust is a Rust implementation of the physically-based renderer described in Pharr, Jakob and Humphreys (2004-2021), <em>Physically Based Rendering: From Theory To Implementation.</em> (https://pbr-book.org/). This book details step-by step implementation notes for building the renderer in Rust. </p>
<p>I am writing them primarily to aid my own understanding, but also in the hope that other Rust/3D rendering initiates might find them useful.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-and-transformations"><a class="header" href="#geometry-and-transformations">Geometry and Transformations</a></h1>
<p>In order to generate 3D images, we need a way of representing fundamental geometric concepts such as vectors, points and rays. This section introduces the mathematics behind these concepts and their implementation in <code>pbrt-rust</code>.</p>
<ul>
<li><a href="geometry_vectors.html">Vectors</a></li>
<li><a href="geometry_points.html">Points</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-and-transformations-1"><a class="header" href="#geometry-and-transformations-1">Geometry and Transformations</a></h1>
<h2 id="11-vectors"><a class="header" href="#11-vectors">1.1 Vectors</a></h2>
<p>A vector is a quantity with a magnitude and a direction. We can imagine a vector as a pointed arrow, where the direction of the arrow signals the direction of the vector, and the length of the arrow represents magnitude.</p>
<p align="center">
    <img src="images/3dvector.png" style="background-color: white" width="200">
</p>
<p><em>Fig 1: A visual representation of a three-dimensional vector.</em></p>
<p>Vectors will give our renderer the mathematical foundation for modeling rays of light. Our renderer will represent vectors in terms of their co-ordinates from the origin. For example, the two-dimensional vector \(V=(1,1)\)
can be visualized as a line starting at the origin (0,0) and extending to the point (4,2).</p>
<p align="center">
    <img src="images/2d_vector.png" style="background-color: white" width="200">
</p>
<p><em>Fig 2: A visual representation of the vector (4,2).</em></p>
<p>To represent vectors in our Rust renderer, we will use two structs: <code>Vector2d</code> for the two-dimensional case, and <code>Vector3d</code> for the three-dimensional case. Because we may want to create vectors of both floating-point and integer types in our rendering application, it's useful to implement these as generic types, as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Vector2d&lt;T&gt; {
    pub x: T,
    pub y: T
}
impl&lt;T&gt; Vector2d&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Vector2d { x, y }
    }
}

pub struct Vector3d&lt;T&gt; {
   pub x: T,
   pub y: T,
   pub z: T
}
impl&lt;T&gt; Vector3d&lt;T&gt; {
    pub fn new(x: T, y: T, z: T) -&gt; Self {
        Vector3d { x, y, z }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>For the remainder of these examples, I'll focus on the implementations for the <code>Vector3d</code> class, which are essentially the same as for <code>Vector2d</code>.</p>
<p>The components of vectors can be accessed as simple properties on the struct (<code>vec.x</code>, <code>vec.y</code> etc.). For some algorithms, it is also useful to be able to iterate over the components of vectors, so in addition to allowing access by property, we overload the index operator to allow <code>vec[0]</code>, <code>vec[1]</code> etc. To overload operators in Rust, we import the relevant trait from std::ops and provide an impl statement, as below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Index;

impl&lt;T&gt; Index&lt;usize&gt; for Vector3d&lt;T&gt; {
    type Output = T;
    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        match index {
            0 =&gt; &amp;self.x,
            1 =&gt; &amp;self.y,
            2 =&gt; &amp;self.z,
            _ =&gt; panic!(&quot;Index out of bounds&quot;)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="adding-and-subtracting-vectors"><a class="header" href="#adding-and-subtracting-vectors">Adding and subtracting vectors</a></h3>
<p>To add two vectors we just add up the components item-by-by item. So if we have two three-dimensional vectors \(V\) and \(W\), their sum is a new vector where each component is the sum of the corresponding components of V and W:</p>
<p>\[
V=(1,3,5) \\
W=(2,4,6)  \\
V+W=(Vx+Wx,Vy+Wy,Vz+Wz) \\
=(1+2,3+4,5+6) \\
=(3,7,11) \\
\]</p>
<p>The geometric interpretation of vector addition is equivalent to imagining the two vectors arranged to form a path, where the first vector starts at the origin, and the second vector starts where the first terminates. If we follow the second vector to its terminus, we find outselves at the co-ordinates representing the components of the new vector. The diagram below shows this for two vectors \(V=(4,2)\) and \(W=(−1,3)\), giving the expected result of \(V+W=(3,5)\)</p>
<p align="center">
    <img src="images/vector_addition.png" style="background-color: white" width="200">
</p>
<p><em>Fig 3: Geometric interpretation of vector addition.</em></p>
<p>As one might expect, subtraction is also applied elementwise:</p>
<p>\[
V=(1,3,5) \\
W=(2,4,6) \\
V−W=(V_x−W_x,V_y−W_y,V_z−W_z) \\
=(1−2,3−4,5−6) \\
=(−1,−2,−1) \\
\]
The geometric interpretation of vector subtraction is equivalent to imagining both vectors as paths originating at the origin, and finding the vector which connects the second operand to the first operand. The diagram below shows this for two vectors \(V=(5,2)\)
and \(W=(3,5)\). Subtracting V from W gives us \(W−V=(−2,3)\).</p>
<p align="center">
    <img src="images/vector_subtraction.png" style="background-color: white" width="200">
</p>
<p><em>Fig 4: Geometric interpretation of vector subtraction.</em></p>
<p>To implement these operations in Rust, we import the <code>std::ops::Add</code> and <code>std::ops::Sub</code> traits and provide implementations with <code>impl</code> statements. Things get a little tricky here, because the implementations will need to use the + and - operator on the vector components; however, because we are using generics, we are unable to guarantee that the components (which could be of any type) actually support these operators. To get around this, we can use the <code>num::Real</code> trait as a trait bound on our implementations, meaning that the <code>Vector</code> structs can only be created with numeric types which represent real numbers.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use num::Real;

impl&lt;T:Real&gt; Vector3d&lt;T&gt; {
    fn new(x: T, y: T, z: T) -&gt; Self {
        Vector3d { x, y, z }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>impl&lt;T:Real</code> statement means that we are implementing the new constructor only for types which represent real numbers. With this in place, we can import the <code>Add</code> and <code>Sub</code> traits from the <code>std::ops</code> crate, and define our addition and subtraction operations:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::{Index, Add, Sub};

impl &lt;T:Real&gt; Add for Vector3d&lt;T&gt; {
    type Output = Vector3d&lt;T&gt;;
    fn add(self, other: Self) -&gt; Self::Output {
        Vector3d::new(self.x + other.x, self.y + other.y, self.z + other.z)
    }
}
impl &lt;T:Real&gt; Sub for Vector3d&lt;T&gt; {
    type Output = Vector3d&lt;T&gt;;
    fn sub(self, other: Self) -&gt; Self::Output {
        Vector3d::new(self.x - other.x, self.y - other.y, self.z - other.z)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="vector-negation"><a class="header" href="#vector-negation">Vector negation</a></h3>
<p>Negating a vector can be achieved by negating each component. It results in a vector of the same magnitude pointing in the opposite direction. We can implement this in a similar manner to the other operations -- importing the <code>Neg</code> trait from <code>std::ops</code> and providing an implementation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;T:Real&gt; Neg for Vector3d&lt;T&gt; {
    type Output = Vector3d&lt;T&gt;;
    fn neg(self) -&gt; Self::Output {
        Vector3d::new(-self.x, -self.y, -self.z)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="scalar-multiplication-and-division"><a class="header" href="#scalar-multiplication-and-division">Scalar multiplication and division</a></h3>
<p>A vector can be multiplied and divided by a scalar value. To implement this, we just apply the multiplication/division operation element-wise to the vector.</p>
<p>So scalar multiplication will look like this:</p>
<p>\[
V=(1,3,5) \\
n=10 \\
Vn=(V_x+n,V_y+n,V_z+n) \\
=(1x10,3x10,5x10) \\
=(10,30,50) \\
\]
...and scalar division will look like this:</p>
<p>\[
V=(1,3,5) \\
n=2 \\
Vn=(V_xn,V_yn,V_zn) \\
=(12,32,52) \\
=(0.5,1.5,2.5) \\
\]</p>
<p>The geometric interpretation of these operations that they scale the vector's magnitude by the scalar degree. So the vector \(V=(2,2)\)
(of length two) multipled by 2 will become \((4,4)\), which is of length 4; dividing this by 2 returns the original value of \(V\)</p>
<p align="center">
    <img src="images/vector_scalar_mul.png" style="background-color: white" width="200">
</p>
<p><em>Fig 5: Geometric interpretation of multiplying a vector by a scalar.</em></p>
<p>In Rust code, this is pretty much the same as what we did for the <code>Add</code> and <code>Sub</code> operations -- we again import the relevant traits from the <code>std::ops</code> library, and provide implementations.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::{Index, Add, Sub, Mul, Div};

impl &lt;T:Real&gt; Mul for Vector3d&lt;T&gt; {
    type Output = Vector3d&lt;T&gt;;
    fn mul(self, other: Self) -&gt; Self::Output {
        Vector3d::new(self.x * other.x, self.y * other.y, self.z * other.z)
    }
}
impl &lt;T:Real&gt; Div for Vector3d&lt;T&gt; {
    type Output = Vector3d&lt;T&gt;;
    fn div(self, other: Self) -&gt; Self::Output {
        Vector3d::new(self.x / other.x, self.y / other.y, self.z / other.z)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-dot-product-of-two-vectors"><a class="header" href="#the-dot-product-of-two-vectors">The dot product of two vectors</a></h2>
<p>The dot product gives us a measure of the similarity between two vectors. This will be useful for doing things like calculating the angle at which light strikes a surface. To take the dot product of two vectors, we multiply their components element-wise, and sum the result:</p>
<p>\[
V \cdot W = \sum_{i=1}^n V_iW_i\\
\]</p>
<p>For example, the dot product of \(V = (2, 3, 4\) and \(W = (4, 3, 2)\) is:</p>
<p>\[
(V_xW_x, V_yW_y, V_zW_z)\\
= (2 x 4, 3 x 3, 4 x 2)\\
= (8, 9, 8)
\]</p>
<p>The dot product is useful because of its relationship to the angle between the two vectors -- it is equal to the product of the lengths of the vectors times the cosine of the angle between them:</p>
<p>\[
V \cdot W = |V| |W| cos \theta
\]</p>
<p>A consequence of this is that if both vectors are normalized to have a length of one (see: 'Vector Normalization' below), the magnitudes can be disregarded by removing the first term from the above equation, so we have:</p>
<p>\[
\hat{V} \cdot \hat{W} = cos \theta
\]</p>
<p>So the dot product allows us to directly calculate the cosine of the angle between two vectors. When the dot product is 0, this means that the two vectors are exactly perpendicular; when it is 1, it means that the two vectors are parallel, and when it is -1, the vectors point in the opposite directions.</p>
<p align="center">
    <img src="images/dot_product_zero.png" style="background-color: white" width="200">
    <img src="images/dot_product_one.png" style="background-color: white" width="200">
    <img src="images/dot_product_negative.png" style="background-color: white" width="200">
</p>
<p><em>Fig 6: Geometric interpretation of the dot product for unit vectors.</em></p>
<p>To implement the dot product in our Rust renderer, we add a <code>dot()</code> method to the <code>impl</code> block for our <code>Vector</code> structs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T:Real Vector3d&lt;T&gt; {
    pub fn new(x: T, y: T, z: T) -&gt; Self {
        Vector3d { x, y, z }
    }
    pub fn dot(&amp;self, other: &amp;Self) -&gt; T {
        self.x * other.x + self.y * other.y + self.z * other.z
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-cross-product-of-two-vectors"><a class="header" href="#the-cross-product-of-two-vectors">The cross product of two vectors</a></h2>
<p>The cross product of two three-dimensional vectors allows us to find a vector which is orthogonal to both of them. It can be calculated as follows:</p>
<p>\[
(V \times W)_x = V_yW_z - V_zW_y\\
(V \times W)_y = V_zW_x - V_xW_z\\
(V \times W)_z = V_xW_y - V_yW_x\\
\]</p>
<p>One way to remember this pattern is to observe that for each component of the output vector (x, y, z), the calculation uses the next two components in the sequence. So for \((V \times W)_x\), we use the y and z components of the two input vectors; \((V \times W)_y\) uses z and x, and \((V \times W)_z\) uses x and y. The calculation then proceeds as follows. For each output component:</p>
<ul>
<li>Identify the two target components for this output component. So for \((V \times W)_x\), we are dealing with y and z.</li>
<li>Take the first component (from the target components) on the first input vector, and multiply it with the second component on the second input vector. Our target components are y and z, and our input vectors are \(V\) and \(W\) -- so we multiply \(V_y\) and \(W_z\)</li>
<li>Take the second component (from the target components) on the first input vector, and multiply it with the first component on the second input vector. Our target components are y and z, and our input vectors are \(V\) and \(W\) -- so we multiply \(V_z\) and \(W_y\)</li>
<li>Subtract the second multiplication result from the first.</li>
</ul>
<p>The geometric interpretation of the cross product is that, given two input vectors, it returns a third vector which is orthogonal to the two input vectors. In the image below, vectors \(A\) and \(B\) form a plane in the X-Z dimension, so their cross-product is a vector which points straight up along the Y axis. The angle between this vector and each of the others is 90 degrees.</p>
<p align="center">
    <img src="images/cross_product.png" style="background-color: white" width="200">
</p>
<p>*Fig 7: Geometric interpretation of the cross product.</p>
<p>To implement the cross product for our <code>Vector3d</code> struct, we add it to the relevant <code>impl</code> block. Note that we don't need to do this for <code>Vector2d</code>, as the cross-product is not well-defined for 2d vectors.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T:Real&gt; Vector3d&lt;T&gt; {
    pub fn new(x: T, y: T, z: T) -&gt; Self {
        Vector3d { x, y, z }
    }
    pub fn dot(&amp;self, other: &amp;Self) -&gt; T {
        self.x * other.x + self.y * other.y + self.z * other.z
    }
    pub fn cross(&amp;self, other: &amp;Self) -&gt; Self {
        Vector3d::new(self.y * other.z - self.z * other.y,
                      self.z * other.x - self.x * other.z,
                      self.x * other.y - self.y * other.x)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To test this method, we can consider the case of our typical representation of a 3D space with axes, where each axis is a unit vector extending in one dimension only. So we have an X axis \((1, 0, 0)\), Y axis \((0, 1, 0)\), and Z axis \((0, 0, 1)\). We can retrieve the third axis given two others using the cross product:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_vector_3d_cross() {
    let v1 = Vector3d::new(1.0, 0.0, 0.0);
    let v2 = Vector3d::new(0.0, 1.0, 0.0);
    let v3 = Vector3d::new(0.0, 0.0, 1.0);
    assert_eq!(v1.cross(&amp;v2), v3);
    assert_eq!(v3.cross(&amp;v1), v2);
    assert_eq!(v2.cross(&amp;v3), v1);
}
<span class="boring">}
</span></code></pre></pre>
<p>However, it should be noted that order matters when calculating the cross product. This because there are always two orthogonal vectors given two inputs -- one in each direction. So if we take the cross products in the above test and reverse the operands, we get the inverse result:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_vector_3d_cross_negative() {
    let v1 = Vector3d::new(1.0, 0.0, 0.0);
    let v2 = Vector3d::new(0.0, 1.0, 0.0);
    let v3 = Vector3d::new(0.0, 0.0, 1.0);
    assert_eq!(v2.cross(&amp;v1), -v3);
    assert_eq!(v1.cross(&amp;v3), -v2);
    assert_eq!(v3.cross(&amp;v2), -v1);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="normalization"><a class="header" href="#normalization">Normalization</a></h2>
<p>To normalize a vector we compute a new vector with the same direction but with length one. To achieve this, we first need a way to compute the length of a vector. This can be achieved by taking the square-root of the sum of squared components. So if \(V\) is a vector with \(n\) components, and lower-case \(v_n\) represents each component, the length is calculated as:</p>
<p>\[
|V| = \sqrt{v_1^2 + v_2^2 ... v_n^2 }\\
\]</p>
<p>To get the normalized vector, we divide it by the length, which is achieved by applying the division to each component:</p>
<p>\[
\hat{V} = \frac{V}{|V|}\\
= (\frac{V_x}{|V|}, \frac{V_y}{|V|}, \frac{V_z}{|V|})\\
\]</p>
<p>In our Rust code, we can achieve this with a few additional methods for our <code>Vector</code> implementations -- <code>squared_length()</code>, <code>length()</code> and <code>normalized()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T:Real&gt; Vector3d&lt;T&gt; {
    ...
    pub fn squared_length(&amp;self) -&gt; T {
        self.x * self.x + self.y * self.y + self.z * self.z
    }
    pub fn length(&amp;self) -&gt; T {
        self.squared_length().sqrt()
    }
    pub fn normalized(&amp;self) -&gt; Self {
        Vector3d {
            x: self.x / self.length(),
            y: self.y / self.length(),
            z: self.z / self.length()
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="miscellaneous-operations"><a class="header" href="#miscellaneous-operations">Miscellaneous Operations</a></h2>
<p>There are several other methods included for Vectors in the C++ pbrt implementation. These include;</p>
<ul>
<li>Methods for retrieving the max and min component of a vector (<code>min_component()</code> and <code>max_component()</code>)</li>
<li>A method for retrieving the index of the component with the largest value (<code>max_dimension()</code>)</li>
<li>Component-wise minimum and maximum operations (<code>min()</code> and <code>max()</code>)</li>
<li>A method for permuting a vector based on input indices (<code>permute()</code>)</li>
</ul>
<h2 id="generating-a-coordinate-system-from-an-input-vector"><a class="header" href="#generating-a-coordinate-system-from-an-input-vector">Generating a coordinate system from an input vector</a></h2>
<p>We will frequently want to construct a local coordinate system given only a single 3D vector. 
Because the cross product of two vectors is orthogonal to both, we can apply the cross product two times to get a set of three orthogonal vectors for the coordinate system. The corresponding method on our Rust implemention of <code>Vector3d</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T:Real&gt; Vector3d&lt;T&gt; {
    ...
    pub fn coordinate_system(&amp;self) -&gt; (Self, Self) {
        let y = if self.x.abs() &gt; self.y.abs() {
            Vector3d::new(-self.z, zero(), self.x) / 
            (self.x * self.x + self.z * self.z).sqrt()
        } else {
            Vector3d::new(zero(), self.z, -self.y) / 
            (self.y * self.y + self.z * self.z).sqrt()
        };
        (self.cross(&amp;y), y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>One thing of note here is the <code>zero()</code> function imported from <code>num</code> -- this allows us to provide a 0 value as default without specifying a type. If we used <code>0.0</code> here, the Rust compiler would complain, as this would commit us to a vector of floats, but we have defined <code>Vector</code> as a generic type.</p>
<p>In a similar manner to the tests for the cross product, we can test this method by passing it a unit vector in X (\(1, 0, 0)\) -- we expect it to return corresponding orthogonal vectors in Y and Z. We can further convince ourselves that these are orthogonal using the dot product, as we expect a value of zero for the dot product of two orthogonal vectors.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_vector_3d_coordinate_system() {
    let v = Vector3d::new(1.0, 0.0, 0.0).normalized();
    let (v1, v2) = v.coordinate_system();
    assert_eq!(v1, Vector3d::new(0.0, -1.0, 0.0));
    assert_eq!(v2, Vector3d::new(0.0, 0.0, 1.0));
    assert_eq!(v1.dot(&amp;v2), 0.0);
    assert_eq!(v2.dot(&amp;v1), 0.0);
    assert_eq!(v.dot(&amp;v1), 0.0);
    assert_eq!(v.dot(&amp;v2), 0.0);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-and-transformations-2"><a class="header" href="#geometry-and-transformations-2">Geometry and Transformations</a></h1>
<h2 id="12-points"><a class="header" href="#12-points">1.2 Points</a></h2>
<p>A point is a location in 2d or 3d space. 
We can represent points in terms of their co-ordinates -- so \(x,y\) for 2d and \(x,y,z\) for 3d points.
Although this is the same basic representation as vectors, the fact that they represent positions instead of directions means that they will be treated differently. The Rust structs for points look similar to vectors:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Point2D&lt;T&gt; {
    pub x: T,
    pub y: T,
}
impl&lt;T: Scalar&gt; Point2D&lt;T&gt; {
    pub fn new(x: T, y: T) -&gt; Self {
        Point2D{x, y}
    }
}
pub struct Point3D&lt;T&gt; {
    pub x: T,
    pub y: T,
    pub z: T,
}
impl&lt;T: Scalar&gt; Point3D&lt;T&gt; {
    pub fn new(x: T, y: T, z: T) -&gt; Self {
        Point3D{x, y, z}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The C++ pbrt implementation also includes methods for:</p>
<ul>
<li>Converting a 3d point to 2d by dropping the 'z' component.</li>
<li>Converting points of one type (e.g. floats) to another (e.g. int)</li>
<li>Converting a point of one type to a vector of another type.</li>
</ul>
<p>To achieve this in Rust, we can add appropriate methods to the <code>Point</code> implementations.
To do the type conversions, we need to add additional type parameters. Taking the conversion of <code>Point3d</code> betweent types as an example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Point3d&lt;T&gt; {
    ...
    pub fn from&lt;U, V: From&lt;U&gt;&gt;(p: Point3d&lt;U&gt;) -&gt; Point3d&lt;V&gt; {
        Point3d{x: p.x.into(), y: p.y.into(), z: p.z.into()}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>from&lt;U, V&gt;</code> statement declares two generic types, then <code>(p: Point3d&lt;U&gt;) -&gt; Point3d&lt;V&gt;</code> specifies that we will take an argument of one type and convert to the other. The trait bound on <code>V</code>, <code>V: From&lt;U&gt;</code> means that we will only support types which support this conversion. Types that satisfy this trait will have an <code>into()</code> method which will do the cast for us.</p>
<h2 id="operations-on-vectors-and-points"><a class="header" href="#operations-on-vectors-and-points">Operations on vectors and points</a></h2>
<p>We can add or subtract vectors and points by applying the addition/subtraction operation componentwise. Adding and subtracting vectors and points has the affect of offsetting the point along the vector. So if we think of a vector as a path, if we start at point A and add the vector, we end up at point B. Subtraction has the opposite affect -- if we start at point A and subtract the vector, we walk in the opposite direction of its trajectory.</p>
<p align="center">
    <img src="images/vector_point_addition.png" style="background-color: white" width="200">
    <img src="images/vector_point_subtraction.png" style="background-color: white" width="200">
</p>
<p><em>Fig 1: Geometrical interpretation of vector-point addition (left) and vector-point subtraction (right).</em></p>
<p>To implement these in Rust, we can follow the same pattern as for vectors -- importing the <code>std::ops::Add</code> and <code>std::ops::Sub</code> traits and providing implementations.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Add&lt;Vector3d&lt;T&gt;&gt; for Point3d&lt;T&gt; {
    type Output = Self;
    fn add(self, other: Vector3d&lt;T&gt;) -&gt; Self {
        Point3d{x: self.x + other.x, y: self.y + other.y, z: self.z + other.z}
    }
}
impl&lt;T: Scalar&gt; Sub&lt;Vector3d&lt;T&gt;&gt; for Point3d&lt;T&gt; {
    type Output = Self;
    fn sub(self, other: Vector3d&lt;T&gt;) -&gt; Self {
        Point3d{x: self.x - other.x, y: self.y - other.y, z: self.z - other.z}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Subtracting two points gives us the vector between them, as shown below:</p>
<p align="center">
    <img src="images/point_point_subtraction.png" style="background-color: white" width="200">
</p>
<p>This means that we can easily find the distance between two points by subtracting them and taking the length of the resulting vector. We can implement this by using the <code>length()</code> method added to the <code>Vector</code> structs in the previous chapter. First we implement <code>Sub</code> for points, which returns a vector:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Sub&lt;Point3d&lt;T&gt;&gt; for Point3d&lt;T&gt; {
    type Output = Vector3d&lt;T&gt;;
    fn sub(self, other: Self) -&gt; Self::Output {
        Vector3d{x: self.x - other.x, y: self.y - other.y, z: self.z - other.z}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we add the <code>distance</code> method to the <code>impl</code> block for the <code>Point</code> structs. I've also added <code>distance_squared</code> following the c++ pbrt implementation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Point3d&lt;T&gt; {
    ...
    pub fn distance(self, other: Self) -&gt; T {
        return (self - other).length();
    }
    pub fn distance_squared(self, other: Self) -&gt; T {
        return (self - other).squared_length();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Following the pbrt book, we also include methods for adding points and scalar multiplication with a point, which are similar to the implementation for <code>Vector</code>.</p>
<h2 id="linear-interpolation"><a class="header" href="#linear-interpolation">Linear interpolation</a></h2>
<p>It's often necessary to interpolate between two points. For example, given the two points \((x_0, y_0)\) and \((x_1, y_1)\) in the image below, we may want to find some intermediate point \((x, y)\).</p>
<p align="center">
    <img src="images/linear_interpolation.png" style="background-color: white" width="200">
</p>
<p><em>Fig 2: Linear interpolation</em></p>
<p>The goal of interpolation is to be able to return arbitrary points which lie between two values. So we are aiming for a method with the following signature:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Point2d&lt;T&gt; {
    ...
    pub fn lerp(&amp;self, t: T, p0: Point2d&lt;T&gt;, p1: Point2d&lt;T&gt;) -&gt; Point2d&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>We want this method to return a point at p0 when the <em>t</em> argument is 0, and a point at p1 when the value of t is 1.
We can interpolate between two points by imagining a straight line between them, as in the above diagram, then picking points along it. We can get a line like this by finding the vector between the two points (using subtraction, as implemented earlier), then multiplying the resulting vector by some amount. For example, if we scale it by 0.5, we get a vector pointing in the same direction, but with half the length. We then just need to add the starting point (if we just took the x and y values of the vector, our line would start from the origin).</p>
<p align="center">
    <img src="images/lerp_1.png" style="background-color: white" width="150">
        <img src="images/lerp_2.png" style="background-color: white" width="150">
            <img src="images/lerp_3.png" style="background-color: white" width="150">
                <img src="images/lerp_4.png" style="background-color: white" width="150">
</p>
<p><em>Fig 3: Linear interpolation by finding the vector between two points then scaling it.</em></p>
<p>The above process can be translated into code as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Point2d&lt;T&gt; {
    ...
        pub fn lerp(self, other: Self, t: T) -&gt; Self {
        return self + (other - self) * t;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="miscellaneous-point-operations"><a class="header" href="#miscellaneous-point-operations">Miscellaneous point operations</a></h2>
<p>The c++ implementation of pbrt includes:</p>
<ul>
<li>operations for returning component-wise min and max</li>
<li>operations for applying floor(), ceil(), and abs() to each component and returning a new point</li>
<li>a permute operation which returns a new point with components permuted based on some indices</li>
</ul>
<p>These are mostly straightfoward, although it should be noted that floor() and ceil() are only defined for floating-point types, so we need to define these in a separate <code>impl</code> block which specifies the <code>Float</code> trait bound:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar + Float&gt; Point3d&lt;T&gt; {
    pub fn floor(self) -&gt; Self {
        Point3d::new(self.x.floor(), self.y.floor(), self.z.floor())
    }
    pub fn ceil(self) -&gt; Self {
        Point3d::new(self.x.ceil(), self.y.ceil(), self.z.ceil())
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-and-transformations-3"><a class="header" href="#geometry-and-transformations-3">Geometry and Transformations</a></h1>
<h2 id="13-normals"><a class="header" href="#13-normals">1.3 Normals</a></h2>
<p>A normal vector is a vector which is perpendicular to a surface at particular point. To calculate it, we take the cross product of any two nonparallel vectors which are tangent to the surface at a point.</p>
<p>For example, in the diagram below, C is a normal vector of the plane formed by A and B:</p>
<p align="center">
    <img src="images/normal_vector.png" style="background-color: white" width="200">
</p>
<p>Normals look a lot like vectors, but behave differently, particularly when it comes to transformations. My Rust implementation of pbrt will follow the original implementation in defining them as a separate type, <code>Normal3d</code>.
<code>Normal3d</code> includes all of the functionality of <code>Vector3d</code>, with the exception of the cross product. </p>
<p>The c++ pbrt implementation also includes a method called <code>FaceForward</code>, which flips a surface normal so that it lies in the same hemisphere as a given vector. This is implemented for all four combinations of Normals and Vectors, and provides an opportunity to further experiment with Rust generics. Here's the <code>FaceForward</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Flip a surface normal so that it lies in the same hemisphere as a given vector.
/// This is useful for computing the reflection direction.
/// This trait provides default behavior for any combination of vector types.
pub trait FaceForward&lt;T: Dot&lt;T, U&gt; + Clone + Neg&lt;Output = T&gt;, U: Scalar&gt;: Dot&lt;T, U&gt; {
    fn face_forward(&amp;self, other: T) -&gt; T {
        if self.dot(&amp;other) &lt; zero() {
            other.clone()
        } else {
            -other.clone()
        }
    }
}
/// Implements the FaceForward trait for any combination of vector types.
impl&lt;U: Scalar, T: Dot&lt;T, U&gt; + Clone + Neg&lt;Output = T&gt;, V: Dot&lt;T, U&gt;&gt; FaceForward&lt;T, U&gt; for V{}
<span class="boring">}
</span></code></pre></pre>
<p>This trait provides default behaviour for any type which can perform a dot() operation with some other type, where that type can be cloned and negated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-and-transformations-4"><a class="header" href="#geometry-and-transformations-4">Geometry and Transformations</a></h1>
<h2 id="14-rays"><a class="header" href="#14-rays">1.4 Rays</a></h2>
<p>A ray is a semi-infinite line specified by a point \(o\) representing its origin and a vector \(d\) representing its direction.</p>
<p align="center">
    <img src="images/ray_point_vector.svg" style="background-color: white" width="200">
</p>
<p>The parametric form of a ray expresses it as a function of a scalar value \(t\), giving the set of points that the ray passes through: </p>
<p>\[
r(t) = o + td  \quad   0 \le t &lt; \infty
\]</p>
<p>The <code>Ray</code> class implements an <code>at(t)</code> method, allowing a caller to retrieve a point along the ray:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct Ray&lt;T&gt; {
    pub origin: Point3d&lt;T&gt;,
    pub direction: Vector3d&lt;T&gt;,
    pub t_max: Cell&lt;T&gt;,
    pub time: T
}
impl&lt;T: Scalar&gt; Ray&lt;T&gt; { 
    pub fn new(origin: Point3d&lt;T&gt;, direction: Vector3d&lt;T&gt;, tmax: T, time: T) -&gt; Self {
        Ray {
            origin,
            direction,
            t_max: Cell::new(tmax),
            time
        }
    }
    pub fn default() -&gt; Self {
        Ray {
            origin: Point3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            direction: Vector3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            t_max: Cell::new(T::inf()),
            time: T::zero()
        }
    }
    pub fn at(&amp;self, t: T) -&gt; Point3d&lt;T&gt; {
        self.origin + self.direction * t
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As with the c++ implementation, the <code>Ray</code> struct provides an all-argument constructor as well as a <code>default()</code> which sets the origin, direction and time values to 0, and t_max to infinity. The Ray also includes a member variable that limits the ray to a segment along its infinite extent. This field, tMax, allows us to restrict the ray to a segment of points. Following the c++ pbrt implementation, this fields needs to be mutable to allow a caller to modify it (this will be useful when recording the points where the ray intersects with an object). In order to make a single field mutable in rust, we need to use the <code>Cell&lt;T&gt;</code> struct. This will allow a caller to set and get the value using the <code>set</code> and <code>get</code> methods on <code>Cell&lt;T&gt;</code>.</p>
<h1 id="142-ray-differentials"><a class="header" href="#142-ray-differentials">1.4.2 Ray Differentials</a></h1>
<p>The c++ pbrt implementation includes a subclass of <code>Ray</code> with additional information about two auxiliary rays. These extra rays represent camera rays offset by one sample in the \(x\) and \(y\) direction from the main ray on the film plane. By moving the <code>Ray</code> methods out to a trait and implementing them for both <code>Ray</code> and <code>RayDifferential</code>, we can enable geometry methods which act on both <code>Rays</code> and <code>RayDifferentials</code> without caring which underlying type they are dealing with. Here's what the <code>RayMethods</code> trait looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait RayMethods&lt;T&gt; {
    fn origin(&amp;self) -&gt; Point3d&lt;T&gt;;
    fn direction(&amp;self) -&gt; Vector3d&lt;T&gt;;
    fn at(&amp;self, t: T) -&gt; Point3d&lt;T&gt;;
    fn t_max(&amp;self) -&gt; &amp;Cell&lt;T&gt;;
    fn time(&amp;self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<p>We can then add impl blocks returning the appropriate fields for both <code>Ray</code> and <code>RayDifferential</code>. <code>RayDifferential</code> has a few extra fields and methods:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RayDifferential&lt;T&gt; {
    pub origin: Point3d&lt;T&gt;,
    pub direction: Vector3d&lt;T&gt;,
    pub t_max: Cell&lt;T&gt;,
    pub time: T,
    pub rx_origin: Point3d&lt;T&gt;,
    pub ry_origin: Point3d&lt;T&gt;,
    pub rx_direction: Vector3d&lt;T&gt;,
    pub ry_direction: Vector3d&lt;T&gt;,
    pub has_differentials: bool
}
impl&lt;T: Scalar&gt; RayDifferential&lt;T&gt; {
    pub fn new(origin: Point3d&lt;T&gt;, direction: Vector3d&lt;T&gt;, tmax: T, time: T) -&gt; Self {
        RayDifferential {
            origin: origin,
            direction: direction,
            rx_origin: Point3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            rx_direction: Vector3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            ry_origin: Point3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            ry_direction: Vector3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            t_max: Cell::new(tmax),
            time: time,
            has_differentials: false
        }
    }
    pub fn default() -&gt; Self {
        RayDifferential {
            origin: Point3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            direction: Vector3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            rx_origin: Point3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            rx_direction: Vector3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            ry_origin: Point3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            ry_direction: Vector3d::&lt;T&gt;::new(T::zero(), T::zero(), T::zero()),
            t_max: Cell::new(T::inf()),
            time: T::zero(),
            has_differentials: false
        }
    }
    pub fn from_ray(ray: &amp;Ray&lt;T&gt;) -&gt; Self {
        RayDifferential::new(ray.origin, ray.direction, ray.t_max.get(), ray.time)
    }
    pub fn scale_differentials(&amp;mut self, s: T) {
        self.rx_origin = self.origin + (self.rx_origin - self.origin) * s;
        self.ry_origin = self.origin + (self.ry_origin - self.origin) * s;
        self.rx_direction = self.direction + (self.rx_direction - self.direction) * s;
        self.ry_direction = self.direction + (self.ry_direction - self.direction) * s;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>RayDifferential</code> the <code>rx_</code> fields describe origin and direction information about these rays, and the 'ScaleDifferentials' method updates the differential rays for an estimated sample spacing of s. Finally, a <code>from_ray_</code> constructor allows us to create a <code>RayDifferential</code> from a <code>Ray</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-and-transformations-5"><a class="header" href="#geometry-and-transformations-5">Geometry and Transformations</a></h1>
<h2 id="15-bounding-boxes"><a class="header" href="#15-bounding-boxes">1.5 Bounding Boxes</a></h2>
<p>A bounding box describes the extent of some region of space. Bounding boxes will be useful for our renderer, because if we divide a space into bounding boxes we can make early decisions about whether calculations need to be done in a particular area (so if you imagine we have 10 complex objects in a box, we can first check if a calculation need sto be done for the box at all, and avoid it if not).</p>
<p align="center">
    <img src="images/bounding_box.png" style="background-color: white" width="200">
</p>
<p><em>Fig 1.1: A bounding box around a set of objects in two dimensions</em></p>
<p>We can represent a bounding box in terms of it's min and max bounds, which are points in space. Here are what the structs look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Bounds2d&lt;T&gt; {
    pub min: Point2d&lt;T&gt;,
    pub max: Point2d&lt;T&gt;,
}
pub struct Bounds3d&lt;T&gt; {
    pub min: Point3d&lt;T&gt;,
    pub max: Point3d&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>impl</code> blocks for the <code>Bounds</code> structs provide a constructor which automatically selects the min and max points from the two arguments, as well as a default method that setting the extent to an invalid configuration, which violates the invariant that pMin.x &lt;= pMax.x. This allows operations involving empty boxes e.g., Union() to return the correct result (otherwise they would contain everything and always be true). I've also included a <code>new_from_point</code> method for returning a box from a single point.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Bounds3d&lt;T&gt; {
    pub fn new(p1: Point3d&lt;T&gt;, p2: Point3d&lt;T&gt;) -&gt; Self {
        let min = Point3d::&lt;T&gt;::new(
            p1.x.min(p2.x),
            p1.y.min(p2.y),
            p1.z.min(p2.z)
        );
        let max = Point3d::&lt;T&gt;::new(
            p1.x.max(p2.x),
            p1.y.max(p2.y),
            p1.z.max(p2.z)
        );
        Bounds3d {
            min,
            max
        }
    }
    pub fn new_from_point(p: Point3d&lt;T&gt;) -&gt; Self {
        Bounds3d {
            min: p,
            max: p
        }
    }
    pub fn default() -&gt; Self {
        Bounds3d {
            min: Point3d{x: T::inf(), y: T::inf(), z: T::inf()},
            max: Point3d{x: -T::inf(), y: -T::inf(), z: -T::inf()}
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The c++ pbrt implementation also has an overloaded 'Union' method for adding both points and other boxes to boxes. We can achieve this in rust with traits as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Union&lt;T&gt; {
    fn union(&amp;self, other: &amp;T) -&gt; Self;
}
impl&lt;T: Scalar&gt; Union&lt;Point2d&lt;T&gt;&gt; for Bounds2d&lt;T&gt; {
    fn union(&amp;self, other: &amp;Point2d&lt;T&gt;) -&gt; Self {
        Bounds2d {
            min: Point2d {
                x: self.min.x.min(other.x),
                y: self.min.y.min(other.y)
            },
            max: Point2d {
                x: self.max.x.max(other.x),
                y: self.max.y.max(other.y)
            }
        }
    }
}
impl&lt;T: Scalar&gt; Union&lt;Bounds2d&lt;T&gt;&gt; for Bounds2d&lt;T&gt; {
    fn union(&amp;self, other: &amp;Bounds2d&lt;T&gt;) -&gt; Self {
        Bounds2d {
            min: Point2d {
                x: self.min.x.min(other.min.x),
                y: self.min.y.min(other.min.y)
            },
            max: Point2d {
                x: self.max.x.max(other.max.x),
                y: self.max.y.max(other.max.y)
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This lets us call <code>union()</code> with either a <code>Point</code> or another <code>Bounds</code>, and have the compiler choose the correct method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-and-transformations-6"><a class="header" href="#geometry-and-transformations-6">Geometry and Transformations</a></h1>
<h2 id="16-transformations"><a class="header" href="#16-transformations">1.6 Transformations</a></h2>
<p>A transformation is a mapping from points to points or from vectors to vectors. In 3D graphics, we are most interested in translations (moving from position to position), scaling, and rotation around an axis.</p>
<p>It turns out that we can express these translations in 4x4 matrices, which, when multiplied with a vector or point, will result a new vector/point with the translation applied. 
The same set of matrices will work for both vectors and points To do this, we first convert our representation of vectors and points into a single, 4 element representation: their <strong>homogeneous coordinates</strong>. The additional component will be zero for a vector, and a non-zero value for points. So both points and vectors will look like this:</p>
<p>\[
p = (x, y, z, 1) \\
v = (x, y, z, 0)
\]</p>
<p>This representation is very convenient, because it means that the operations we might perform on points and vectors will reflect their geometric interpretation. For example, if we subtract two points, we get a vector:</p>
<p>\[
(8, 4, 2. 1) - (3, 2, 1, 1) = (5, 2, 1, 0)
\]</p>
<p>And adding two vectors gives us another vector:</p>
<p>\[
(0, 0, 1, 0) - (1, 0, 0, 0) = (1, 0, 1, 0)
\]</p>
<p>Once we have 4-element tuples like those above, we can construct 4x4 matrices which, when multipled with a point or vector, result in the desired transformation. </p>
<h3 id="scaling"><a class="header" href="#scaling">Scaling</a></h3>
<p>If we want to scale each element of a point or vector, we can construct a matrix like this:</p>
<p>\[
\begin{bmatrix}
5 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 5 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 5 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</p>
<p>Multiplying this with a vector or point will result in the \(x, y, z\) values of the point being multiplied by 5, with the \(w\) value preserved (so scaling a point returns a point, and scaling a vector returns a vector). This is shown below. To multiply a 4-vector and a matrix, we take its dot product with each row in the matrix.</p>
<p>\[
\begin{bmatrix}
5 &amp; 5 &amp; 5 &amp; 1
\end{bmatrix} 
\begin{bmatrix}
5 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 5 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 5 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}=
\begin{bmatrix}
25 &amp; 25 &amp; 25 &amp; 1
\end{bmatrix}
\]</p>
<h3 id="translation"><a class="header" href="#translation">Translation</a></h3>
<p>For translation, we just want to add some scalar value to each element. To do that, we can construct a matrix like this one:</p>
<p>\[
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; T_x\\
0 &amp; 1 &amp; 0 &amp; T_y\\
0 &amp; 0 &amp; 1 &amp; T_z\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</p>
<p>To understand this, we can imagine a point \((3, 3, 3, 1\)) which we want to translate by \(1, 0, 0\). We can just focus on the \(x\) axis as this is the only one we expect to change. We take our input vector and take its dot product with the row vector \((1, 0, 0, 1\)):</p>
<p>\[
(3, 3, 3, 1) \cdot (1, 0, 0, 1)\\
= 3 \times 1 + 3 \times 0 + 3 \times 0 + 1 \times 1 \\
= 3 + 1
\]</p>
<p>So -- the '1' in the first entry of row 1 means we start with the original value of x, then all others are set to zero except for the final value, which will get multipied by 1. To take the dot product, we sum those values, which gives us the expected result of 3 + 1 for x. The translation happens because we multiply the final value of the row by the point's \(w\) value of 1. This has the consequence that translation has no impact on a vector, which makes sense, as vectors have no position.</p>
<h2 id="rotation"><a class="header" href="#rotation">Rotation</a></h2>
<p>To understand how to construct rotation matrices, it's useful to first understand the notion of <strong>basis vectors</strong>. The basis vectors are a set of unit vectors which lie along the axes of a co-ordinate system.</p>
<p align="center">
    <img src="images/basis_vectors.png" style="background-color: white" width="200">
</p>
<p><em>Figure 1: The basis vectors \(\hat{i}\), \(\hat{j}\) and \(\hat{k}\), which are unit vectors parallel to the \(x\), \(y\) and \(z\) axes.</em></p>
<p>\(\hat{i}\) typically describes the unit vector in \(x\); \(\hat{j}\) typically describes the unit vector in \(y\); and \(\hat{k}\) typically describes the unit vector in \(z\). So the basis vectors are:</p>
<p>\[
\hat{i} = 
\begin{bmatrix}
1 \\ 0 \\ 0 \\
\end{bmatrix}
\quad
\hat{j} = 
\begin{bmatrix}
0 \\ 1 \\ 0 \\
\end{bmatrix}
\quad
\hat{k} = 
\begin{bmatrix}
0 \\ 0 \\ 1 \\
\end{bmatrix}
\]</p>
<p>We can think of all vectors in a given co-ordinate system as being composed of these basis vectors. For example, if we imagine this vector:</p>
<p>\[
v = 
\begin{bmatrix}
2 \\ 3 \\ 4
\end{bmatrix}
\]</p>
<p>We can also imagine this as being composed of the basis vectors:</p>
<p>\[
v = 2\hat{i} + 3\hat{j} + 4 \hat{k}
= 2
\begin{bmatrix}
1 \\ 0 \\ 0
\end{bmatrix}
+ 3
\begin{bmatrix}
0 \\ 1 \\ 0
\end{bmatrix}
+ 4
\begin{bmatrix}
0 \\ 0 \\ 1
\end{bmatrix}
= 
\begin{bmatrix}
2 \\ 3 \\ 4
\end{bmatrix}
\]</p>
<p>This means that if we can figure out how to transform the basis vectors, we can transform anything in their space. Let's think about how we might rotate the 2d basis vectors. Figure 2 shows our goal -- we want to take the vectors \(\hat{i}\) (in red) and \(\hat{j}\) (blue) and rotate them by the angle \(\theta\).</p>
<p align="center">
    <img src="images/rotating_basis_vectors.png" style="background-color: white" width="400">
</p>
<p><em>Figure 2: Rotating a vector in two dimensions.</em></p>
<p>To do this, we can imagine the two right-angled triangles formed by each basis vector and the target (rotated) vectors:</p>
<p align="center">
    <img src="images/rotating_basis_vectors_triangles.png" style="background-color: white" width="400">
</p>
<p><em>Figure 3: Using triangles to calculate the x and y values of rotated basis vectors.</em></p>
<p>To find the \(x\) and \(y\) components of the new vectors, we just need to find the length of the base (adjacent side) and height (opposite side) of each of these triangles.</p>
<p>The formulas for sine and cosine allow us to retrieve these values for the angle \(\theta\):</p>
<p>\[
cos(\theta) = \frac{adjacent}{hypotenuse}\\
sin(\theta) = \frac{opposite}{hypotenuse}
\]</p>
<p>Because we are dealing with the basis vectors, which have a length of one, we can remove the division term, giving us:</p>
<p>\[
cos(\theta) = adjacent\\
sin(\theta) = opposite
\]</p>
<p>So for the red basis vector (\(\hat{i}\)), the rotated version is given by:</p>
<p>\[
i_x = cos(\theta)\\
i_y = sin(\theta)\\
\]</p>
<p>For the blue basis vector, the same pattern applies, but because the base of the triangle is along the y-axis, the values correspond to different sides of the triangle: we get \(j_x\) from the length of the opposite side, and \(j_y\) from the length of the adjacent side. We also need to negate the x component, as it extends to the left of the x-axis:</p>
<p>\[
j_x = -sin(\theta)\\
j_y = cos(\theta)\\
\]</p>
<p>Now we know how to calculate the new x and y values for the basis vectors, we can construct a 2x2 matrix to transform them by a given angle:</p>
<p>\[
\begin{bmatrix}
\cos \theta &amp; -\sin \theta \\
\cos \theta &amp; \sin \theta \\
\end{bmatrix}
\]</p>
<p>To verify that this matrix works, we can multiply it with the basis vectors \(\hat{i} = (1, 0)\) and \(\hat{j} = (0, 1)\) used in the previous examples:</p>
<p>\[
R(\hat{i}) = \\
\begin{bmatrix}
\cos \theta &amp; -\sin \theta \\
\cos \theta &amp; \sin \theta \\
\end{bmatrix}
\begin{bmatrix}
1 \\ 0
\end{bmatrix}\\
=
\begin{bmatrix}
(1 \times \cos \theta) - (0 \times \sin \theta) \\ 
(1 \times \sin \theta) + (0 \times \cos \theta) 
\end{bmatrix}\\
=
\begin{bmatrix}
\cos \theta\\ 
\sin \theta\\
\end{bmatrix}
\]</p>
<p>\[
R(\hat{j}) = \\
\begin{bmatrix}
\cos \theta &amp; -\sin \theta \\
\cos \theta &amp; \sin \theta \\
\end{bmatrix}
\begin{bmatrix}
0 \\ 1
\end{bmatrix}\\
=
\begin{bmatrix}
(0 \times \cos \theta) - (1 \times \sin \theta) \\ 
(0 \times \sin \theta) + (1 \times \cos \theta) 
\end{bmatrix}\\
=
\begin{bmatrix}
- \sin \theta\\ 
\cos \theta\\
\end{bmatrix}
\]</p>
<p>To take this into three dimensions, we just need to add an extra dimension, and make it so that one dimension remains unchanged while we rotate the vector around the target axis. So we are looking for three matrices, one per rotation axis, which will leave that component of the vector unchanged whilst modifying the others to reflect the rotation.</p>
<p>\[
M_x = 
\begin{bmatrix}
? &amp; ? &amp; ? \\
? &amp; ? &amp; ? \\
? &amp; ? &amp; ? \\
\end{bmatrix}
\quad
M_y = 
\begin{bmatrix}
? &amp; ? &amp; ? \\
? &amp; ? &amp; ? \\
? &amp; ? &amp; ? \\
\end{bmatrix}
\quad
M_z = 
\begin{bmatrix}
? &amp; ? &amp; ? \\
? &amp; ? &amp; ? \\
? &amp; ? &amp; ? \\
\end{bmatrix}
\]</p>
<p>It's useful to start with the z-axis, because we've actually already covered the meat of it! A 2d rotation can also be imagined as a 3d rotation around the z-axis -- nothing moves in z, and we modify x and y to reflect the rotation. So all we need to do is take the 2d matrix used in the 2d example, move it into 3 dimensions, then ensure that the z axis stays constant. To fix the z axis, we can set the third column of the matrix to the basis vector \(\hat{k}\) = (\(0, 0, 1)\), and set the \(z\) value of the first and second columns (which represent the \(\hat{i}\) and \(\hat{j}\) basis vectors) to 0.</p>
<p>\[
M_z = 
\begin{bmatrix}
\cos \theta &amp; -\sin \theta &amp; 0 \\
\sin \theta &amp; \cos \theta &amp; 0 \\
0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\]</p>
<p>To derive the remaining matrices, we can go back to our original interpretation of rotation as finding the sides of triangles. However, this time we will fix x (which we can imagine projects out of the screen toward us), and manipulate the y and z axes.</p>
<p align="center">
    <img src="images/rotating_basis_vectors_triangles_x.png" style="background-color: white" width="400">
</p>
<p><em>Figure 4: Rotating a vector around the \(x\) axis. We imagine \(x\) as extending out of the screen, and set the remaning axes to y (horizontal) and z (vertical).</em></p>
<p>The red triangle now represents the calculation for basis vector \(\hat{j}\), and the blue triangle now represents the calculation for \(\hat{k}\). To find the y-component of the transformed vector \(j_y\), we need the length of the base of the red triangle, which is \(\cos (\theta)\). 
To find \(j_z\), we need the length of the opposite side of the blue triangle, which is \(\sin (\theta)\). </p>
<p>For \(k\), we get the y-component from the inverse of the length of the opposite side of the blue triangle, so \(-\sin \theta\). The z-component comes from the length of the base of the blue triangle, which is \(\cos \theta\). So we have the following:</p>
<p>\[
j_y = \cos(\theta)\\
j_z = \sin(\theta)\\
k_y = -\sin(\theta)\\
k_z = \cos(\theta)
\]</p>
<p>To create a matrix from these, we first want to ensure that the \(\hat{i}\) basis vector remains constant. To do this, we set the first column to that basis vector:</p>
<p>\[
M_x = 
\begin{bmatrix}
1 &amp; ? &amp; ? \\
0 &amp; ? &amp; ? \\
0 &amp; ? &amp; ? \\
\end{bmatrix}
\]</p>
<p>We also want to ensure that the x-components of the y and z vectors are unaffected by the rotation, so we put zeros in their x-components:</p>
<p>\[
M_x = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; ? &amp; ? \\
0 &amp; ? &amp; ? \\
\end{bmatrix}
\]</p>
<p>The middle column of this matrix represents \(\hat{j}\), and the third column represents \(\hat{k}\):</p>
<p>\[
M_x = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; \hat{j}_y &amp; \hat{k}_y \\
0 &amp; \hat{j}_z &amp; \hat{k}_z \\
\end{bmatrix}
\]</p>
<p>So we can fill in the values we determined above using the triangle method:</p>
<p>\[
M_x = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos(\theta) &amp; -\sin(\theta) \\
0 &amp; \sin(\theta) &amp; \cos(\theta) \\
\end{bmatrix}
\]</p>
<p>To rotate around the Y-axis, we can just do the same trick again: take the triangle analogy above, then imagine that the Y axis is extending out from the screen, with X mapped to the vertical axis and Z mapped to the horizontal axis. We then get:</p>
<p>\[
k_x = \sin(\theta)\\
k_z = \cos(\theta)\\
i_x = \cos(\theta)\\
i_z = -\sin(\theta)
\]</p>
<p>Once again, we want to ensure the rotation axis stays constant, so the middle column of our matrix needs to be set to \(\hat{j}\):</p>
<p>\[
M_x = 
\begin{bmatrix}
? &amp; 0 &amp; ? \\
? &amp; 1 &amp; ? \\
? &amp; 0 &amp; ? \\
\end{bmatrix}
\]</p>
<p>We then set the \(y\) value of the other basis vectors to zero:</p>
<p>\[
M_x = 
\begin{bmatrix}
? &amp; 0 &amp; ? \\
0 &amp; 1 &amp; 0 \\
? &amp; 0 &amp; ? \\
\end{bmatrix}
\]</p>
<p>The first column of this matrix represents \(\hat{i}\), and the final column represets \(\hat{k}\). </p>
<p>\[
M_x = 
\begin{bmatrix}
i_x &amp; 0 &amp; k_x \\
0 &amp; 1 &amp; 0 \\
i_z &amp; 0 &amp; k_z \\
\end{bmatrix}
\]</p>
<p>So we can fill in the values from the triangle method:</p>
<p>\[
M_x = 
\begin{bmatrix}
\cos(\theta) &amp; 0 &amp; \sin(\theta) \\
0 &amp; 1 &amp; 0 \\
-\sin(\theta) &amp; 0 &amp; \cos(\theta) \\
\end{bmatrix}
\]</p>
<p>Finally, to make these transformations compatible with the 4x4 transforms introduced earlier in the section, we need to add padding. This padding will be all zeros, except for the bottom right-hand element of the matrix, which ensures that the w-component of the input is preserved, so a rotated vector is a vector, and a rotated point is a new point. This gives us the following matrices:</p>
<p>\[
R_x(\theta) =
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; cos \theta &amp; - sin \theta &amp; 0\\
0 &amp; -sin \theta &amp; cos \theta &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</p>
<p>\[
R_y(\theta) =
\begin{bmatrix}
cos \theta &amp; 0 &amp;- sin \theta &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
sin \theta &amp; 0 &amp; cos \theta &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</p>
<p>\[
R_z(\theta) =
\begin{bmatrix}
cos \theta &amp; - sin \theta &amp; 0 &amp; 0\\
sin \theta &amp; cos \theta &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</p>
<h2 id="rotating-around-an-arbitrary-axis"><a class="header" href="#rotating-around-an-arbitrary-axis">Rotating around an arbitrary axis</a></h2>
<p>So far we have covered the rotation matrices for the \(x\), \(y\) and \(z\) axes. What if we want to rotate around an arbitrary vector?</p>
<p align="center">
    <img src="images/rotate_arbitrary_axis_1.svg" style="background-color: white" width="400">
</p>
<p><em>Figure 5: Rotating a vector around an arbitrary axis</em></p>
<p>Figure 5 visualizes the the problem -- we want to take the unit vector \(v\) and move it around the axis \(a\) by \(\theta^{\circ}\).</p>
<p>To simplify this problem, we can imagine \(v\) as being composed of two vectors: \(v_{\parallel}\), which is parallel to \(a\), and \(v_{\bot}\), which is perpendicular to \(a\). This is shown in Figure 6.</p>
<p align="center">
    <img src="images/rotate_arbitrary_axis_2.svg" style="background-color: white" width="400">
</p>
<p><em>Figure 6: The vector \(v\) can be decomposed into \(v_{\parallel}\), which is parallel to \(a\), and \(v_{\bot}\), which is perpendicular to \(a\).</em></p>
<p>We can find \(v_{\parallel}\) by projecting \(v\) on to \(a\). The standard formula for a projection is:</p>
<p>\[
\frac{a \cdot b}{|a|^2}a
\]</p>
<p>Because \(a\) is a unit vector, this simplifies to:</p>
<p>\[
v_{\parallel} = (v \cdot a)a
\]</p>
<p>\(v_{\bot}\) can then be found by subtracting \(v_{\parallel}\) from \(v\):</p>
<p>\[
v_{\bot} = v - (v \cdot a) a
\]</p>
<p>Because \(v = v_{\bot} + v_{\parallel}\), to get the rotated vector \(v'\), we can find the sum of the rotation of \(v_{\parallel}\) and \(v_{\bot}\). We already know that the rotation of \(v_{\parallel}\) will be \(v_{\parallel}\), because it is parallel to the axis of rotation \(a\). To find \(v_{\bot}\), we can re-orient our view such that we are looking straight down \(a\). This reduces the problem to a rotation in 2D:</p>
<p align="center">
    <img src="images/rotate_arbitrary_axis_3.svg" style="background-color: white" width="400">
</p>
<p><em>Figure 7: The rotation of \(v_{\bot}\) can be viewed as a rotation in 2d</em></p>
<p>The base of this triangle gives us the x-component of \(v_{\bot}\), and the opposite side gives us the y-component. The base is equal to \(\cos \theta\), and the opposite is equal to \(\sin \theta\). We will need to multiply these by some new basis vectors in order to translate them into our initial frame. The horizontal axis in Figure 7 is easy to find: it's \(v_{\bot}\). If we imagine the view rotated slightly such that we can see \(a\) (Figure 8), it becomes clear that the vertical axis is one perpendicular to both \(v_{\parallel}\) and \(a\), which means we can obtain it from their cross product \(v_{\parallel} \times a\).</p>
<p align="center">
    <img src="images/rotate_arbitrary_axis_4.svg" style="background-color: white" width="400">
</p>
<p><em>Figure 8: The vertical axis when rotating \(v_{\bot}\) is the cross-product of \(v_{\bot}\) and \(a\)</em></p>
<p>Summarizing the derivation, we can decompose \(v\) into \(v_{\parallel}\) and \(v_{\bot}\) as follows:</p>
<p>\[
v_{\parallel} = (v \cdot a)a \\
v_{\bot} = v - (v \cdot a) a
\]</p>
<p>This allows us to express the rotation as:</p>
<p>\[
R(v) = R(v_{\parallel}) + R(v_{\bot}) \\
\]</p>
<p>No rotation is required for \(v_{\parallel}\) because it is parallel to the axis of rotation. The calculation of \(R(v_{\bot})\) can be thought of as a two-dimensional rotation, with each component multipled by a new basis vector to orient the circle of rotation correctly. The horizontal basis is \(v_{\bot}\), and the vertical basis is \(v_{\parallel} \times a\). This gives us:</p>
<p>\[
R(v) = v_{\parallel} + v_{\bot}\cos \theta + (v_{\parallel} \times a) \sin \theta
\]</p>
<h2 id="the-look-at-transformation"><a class="header" href="#the-look-at-transformation">The Look-At Transformation</a></h2>
<p>Given a point representing the location of a camera, a point the camera is looking at, and an 'up' vector which orients the camera along the vector described by the first two parameters, the look-at transformation maps from a left-handed co-ordinate system to one with the camera at the origin, looking along the z-axis, with the y-axis pointing upward. In other words, it lets us describe a camera position and orientation in &quot;world-space&quot; and provides a means of mapping between that space and the camera's viewpoint. The look-at transformation tells us what things look like from the camera's perspective.</p>
<p>To construct this transformation, we can use the same principles applied for the other transformations -- we create a matrix where each column describes the effect of the transformation on the basis vectors of a co-ordinate system.</p>
<p>The fourth column of the matrix gives the origin, and since our camera will be at the origin, we set this to the position of the camera in world space.</p>
<p>\[
position = (x, y, z, 1)\\
lookAt = (x, y, z, 1)\\
up = (x, y, z, 0)\\
\begin{bmatrix}
? &amp; ? &amp; ? &amp; position_x\\
? &amp; ? &amp; ? &amp; position_y\\
? &amp; ? &amp; ? &amp; position_z\\
? &amp; ? &amp; ? &amp; 1\\
\end{bmatrix}
\]</p>
<p>To get \(z\), we compute the normalized vector between the camera's position and the look-at point</p>
<p>\[
position = (x, y, z, 1)\\
lookAt = (x, y, z, 1)\\
up = (x, y, z, 0)\\
direction = \hat{(lookAt - position)}\\
\begin{bmatrix}
? &amp; ? &amp; direction_x &amp; position_x\\
? &amp; ? &amp; direction_y &amp; position_y\\
? &amp; ? &amp; direction_z &amp; position_z\\
? &amp; ? &amp; 0 &amp; 1\\
\end{bmatrix}
\]</p>
<p>For \(x\), we take the cross-product of the 'up' bector with the direction vector, as we know this axis should be orthogonal to 'up' and the direction:</p>
<p>\[
position = (x, y, z, 1)\\
lookAt = (x, y, z, 1)\\
up = (x, y, z, 0)\\
direction = \hat{(lookAt - position)}\\
right = up \times direction\\
\begin{bmatrix}
? &amp; right_x &amp; direction_x &amp; position_x\\
? &amp; right_y &amp; direction_y &amp; position_y\\
? &amp; right_z &amp; direction_z &amp; position_z\\
? &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</p>
<p>Finally, \(y\) is recomputed by taking the cross product of the viewing direction vector with the transformed \(x\)-axis vector:</p>
<p>\[
position = (x, y, z, 1)\\
lookAt = (x, y, z, 1)\\
up = (x, y, z, 0)\\
direction = \hat{(lookAt - position)}\\
right = \hat{up} \times direction\\
newUp = direction \times right\\
\begin{bmatrix}
newUp_x &amp; right_x &amp; direction_x &amp; position_x\\
newUp_y &amp; right_y &amp; direction_y &amp; position_y\\
newUp_z &amp; right_z &amp; direction_z &amp; position_z\\
0 &amp; 0 &amp; 0 &amp; 1\\
\end{bmatrix}
\]</p>
<p align="center">
    <img src="images/look_at.svg" style="background-color: white" width="400">
</p>
<p><em>Figure 9: The look-at transform maps between the co-ordinate system of the world and the co-ordinate system of the camera</em></p>
<h2 id="implementing-the-transformations"><a class="header" href="#implementing-the-transformations">Implementing the transformations</a></h2>
<p>To implement the transformations, we first create a struct for representing 4x4 Matrices, with some basic operations for construction, a multiplication operator, and transposition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Matrix4x4&lt;T&gt; {
    data: [[T;4]; 4]
}
impl&lt;T: Scalar&gt; Matrix4x4&lt;T&gt; {
    pub fn new(data: [[T;4]; 4]) -&gt; Self {
        return Matrix4x4 {
            data
        }
    }
    pub fn from_values(t00: T, t01: T, t02: T, t03: T,
        t10: T, t11: T, t12: T, t13: T,
        t20: T, t21: T, t22: T, t23: T,
        t30: T, t31: T, t32: T, t33: T) -&gt; Self {
            Matrix4x4{
                data: [
                    [t00, t01, t02, t03],
                    [t10, t11, t12, t13],
                    [t20, t21, t22, t23],
                    [t30, t31, t32, t33]
                ]
            }
        }
    pub fn transpose(&amp;self) -&gt; Self {
        return Matrix4x4::from_values(
            self.data[0][0], self.data[1][0], self.data[2][0], self.data[3][0],
            self.data[0][1], self.data[1][1], self.data[2][1], self.data[3][1],
            self.data[0][2], self.data[1][2], self.data[2][2], self.data[3][2],
            self.data[0][3], self.data[1][3], self.data[2][3], self.data[3][3]);
    }
}
impl&lt;T: Scalar&gt; Index&lt;usize&gt; for Matrix4x4&lt;T&gt; {
    type Output = [T;4];
    fn index(&amp;self, x: usize) -&gt; &amp;[T; 4] {
        return &amp;self.data[x];
    }
}
impl&lt;T: Scalar&gt; Mul for Matrix4x4&lt;T&gt; {
    type Output = Matrix4x4&lt;T&gt;;
    fn mul(self, other: Matrix4x4&lt;T&gt;) -&gt; Matrix4x4&lt;T&gt; {
        let mut data: [[T;4];4] = [[T::zero();4];4];
        for i in 0..4{
            for j in 0..4{
                data[i][j] = self[i][0] * other[0][j] + 
                        self[i][1] * other[1][j] + 
                        self[i][2] * other[2][j] + 
                        self[i][3] * other[3][j];
            }
        }
        return Matrix4x4{
            data
        }
    }
}
impl&lt;T: Scalar&gt; Mul&lt;T&gt; for Matrix4x4&lt;T&gt; {
    type Output = Matrix4x4&lt;T&gt;;
    fn mul(self, scalar: T) -&gt; Matrix4x4&lt;T&gt; {
        let mut data: [[T;4];4] = [[T::zero();4];4];
        for i in 0..4{
            for j in 0..4{
                data[i][j] = self.data[i][j] * scalar;
            }
        }
        return Matrix4x4{
            data
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We can then implement a <code>Transform</code> struct which will implement our transformations. The struct has members storing the underling matrix, as well as its inverse, which will be stored by the <code>Transform</code> to avoid having to re-calculate the inverse on demand.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Transform {
    m: Matrix4x4
    m_inv: Matrix4x4
}
<span class="boring">}
</span></code></pre></pre>
<p>There are several constructors for the <code>Transform</code>. The <code>default</code> constructor creates a transform with its matrix set to the identity matrix; the <code>new</code> constructor creates a transform based on a given matrix and its inverse. The remaining methodsr return transform matrices as described in the previous section:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar + Float&gt; Transform&lt;T&gt; {
    pub fn default() -&gt; Self {
        return Transform { 
            m: Matrix4x4::from_values(
                T::one(), T::zero(), T::zero(), T::zero(),
                T::zero(), T::one(), T::zero(), T::zero(),
                T::zero(), T::zero(), T::one(), T::zero(),
                T::zero(), T::zero(), T::zero(), T::one()
            ), 
            m_inv: Matrix4x4::from_values(
                T::one(), T::zero(), T::zero(), T::zero(),
                T::zero(), T::one(), T::zero(), T::zero(),
                T::zero(), T::zero(), T::one(), T::zero(),
                T::zero(), T::zero(), T::zero(), T::one()
            )}
    }
    pub fn new(m: Matrix4x4&lt;T&gt;, m_inv: Matrix4x4&lt;T&gt;) -&gt; Self {
        return Transform { m, m_inv }
    }
    pub fn inverse(&amp;self) -&gt; Self {
        return Transform { m: self.m_inv, m_inv: self.m };
    }
    pub fn transpose(&amp;self) -&gt; Self {
        return Transform { m:self.m.transpose(), m_inv: self.m_inv.transpose() }
    }
    pub fn is_identity(&amp;self) -&gt; bool {
        let identity = Matrix4x4::from_values(
            T::one(), T::zero(), T::zero(), T::zero(),
            T::zero(), T::one(), T::zero(), T::zero(),
            T::zero(), T::zero(), T::one(), T::zero(),
            T::zero(), T::zero(), T::zero(), T::one()
        );
        return self.m.eq(&amp;identity);
    }
    pub fn translate(delta: Vector3d&lt;T&gt;) -&gt; Transform&lt;T&gt; {
        let m = Matrix4x4::from_values(
            T::one(), T::zero(), T::zero(), delta.x,
             T::zero(), T::one(), T::zero(), delta.y,
              T::zero(), T::zero(), T::one(), delta.z,
               T::zero(), T::zero(), T::zero(),T::one());
        let m_inv = Matrix4x4::from_values(
            T::one(), T::zero(), T::zero(), -delta.x,
            T::zero(), T::one(), T::zero(), -delta.y,
             T::zero(), T::zero(), T::one(), -delta.z,
              T::zero(),T::zero(), T::zero(), T::one());
        return Transform{m, m_inv};
    }
    pub fn scale(x:T, y:T, z:T) -&gt; Transform&lt;T&gt; {
        let m = Matrix4x4::from_values(            
        x, T::zero(), T::zero(), T::zero(),
        T::zero(), y, T::zero(), T::zero(),
        T::zero(), T::zero(), z, T::zero(),
        T::zero(), T::zero(), T::zero(), T::one());
        let m_inv = Matrix4x4::from_values(            
            T::one()/x, T::zero(), T::zero(), T::zero(),
            T::zero(), T::one()/y, T::zero(), T::zero(),
            T::zero(), T::zero(), T::one()/z, T::zero(),
            T::zero(), T::zero(), T::zero(), T::one());
        return Transform{m, m_inv};
    }
    pub fn has_scale(&amp;self) -&gt; bool {
        return true;
    }
    pub fn rotate_z(angle: T) -&gt; Self {
        let (mut sin, mut cos) = angle.sin_cos();
        sin = sin.to_radians();
        cos = cos.to_radians();
        let m = Matrix4x4::from_values(
            cos, -sin, T::zero(), T::zero(),
            sin, cos, T::zero(), T::zero(),
            T::zero(), T::zero(), T::one(), T::zero(),
            T::zero(), T::zero(), T::zero(), T::one()
        );
        return Transform { 
            m, 
            m_inv: m.transpose()}
    }
    pub fn rotate_y(angle: T) -&gt; Self {
        let (mut sin, mut cos) = angle.sin_cos();
        sin = sin.to_radians();
        cos = cos.to_radians();
        let m = Matrix4x4::from_values(
            cos, T::zero(), sin, T::zero(),
            T::zero(), T::one(), T::zero(), T::zero(),
            -sin, T::zero(), cos, T::zero(),
            T::zero(), T::zero(), T::zero(), T::one()
        );
        return Transform { 
            m, 
            m_inv: m.transpose()}
    }
    pub fn rotate_x(angle: T) -&gt; Self {
        let (mut sin, mut cos) = angle.sin_cos();
        sin = sin.to_radians();
        cos = cos.to_radians();
        let m = Matrix4x4::from_values(
            T::one(), T::zero(), T::zero(), T::zero(),
            T::zero(), cos, -sin, T::zero(),
            T::zero(), sin, cos, T::zero(),
            T::zero(), T::zero(), T::zero(), T::one()
        );
        return Transform { 
            m, 
            m_inv: m.transpose()}
    }
    pub fn rotate(angle: T, axis: Vector3d&lt;T&gt;) -&gt; Transform&lt;T&gt; {
        let a = axis.normalized();
        let (mut sin, mut cos) = angle.sin_cos();
        sin = sin.to_radians();
        cos = cos.to_radians();
        let mut m = Matrix4x4::default();
        // Compute rotation of first basis vector
        m.data[0][0] = a.x * a.x + (T::one() - a.x * a.x) * cos;
        m.data[0][1] = a.x * a.y * (T::one() - cos) - a.z * sin;
        m.data[0][2] = a.x * a.z * (T::one() - cos) + a.y * sin;
        m.data[0][3] = T::zero();
        // Compute rotations of second and third basis vectors
        m.data[1][0] = a.x * a.y * (T::one() - cos) + a.z * sin;
        m.data[1][1] = a.y * a.y + (T::one() - a.y * a.y) * cos;
        m.data[1][2] = a.y * a.z * (T::one() - cos) - a.x * sin;
        m.data[1][3] = T::zero();
        
        m.data[2][0] = a.x * a.z * (T::one() - cos) - a.y * sin;
        m.data[2][1] = a.y * a.z * (T::one() - cos) + a.x * sin;
        m.data[2][2] = a.z * a.z + (T::one() - a.z * a.z) * cos;
        m.data[2][3] = T::zero();
        return Transform{m, m_inv: m.transpose()};
    }
    pub fn look_at(pos: Point3d&lt;T&gt;, target: Point3d&lt;T&gt;, up: Vector3d&lt;T&gt;) -&gt; Self {
        let dir = (target - pos).normalized();
        let right = up.cross(&amp;dir).normalized();
        let new_up = dir.cross(&amp;right);
        let m = Matrix4x4::from_values(
            right.x, new_up.x, dir.x, pos.x,
            right.y, new_up.y, dir.y, pos.y,
            right.z, new_up.z, dir.z, pos.z,
            T::zero(), T::zero(), T::zero(), T::one()
        );
        return Transform{m, m_inv: m.inverse()};
    }
<span class="boring">}
</span></code></pre></pre>
<p>The c++ pbrt implementation overloads the function operator to apply transforms, but rust does not allow this (it also does not allow method overloading).
To work around this, I have overloaded the <code>Mul</code> operator for the types which we will want to apply transformations to. For example, for <code>Vector3d</code>, we provide a <code>Mul</code> implementation for a matrix and a vector, then for a vector and a transform as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Mul&lt;Vector3d&lt;T&gt;&gt; for Matrix4x4&lt;T&gt; {
    type Output = Vector3d&lt;T&gt;;
    fn mul(self, other: Vector3d&lt;T&gt;) -&gt; Vector3d&lt;T&gt; {
        let mut data: [T;3] = [T::zero();3];
        for i in 0..3{
            data[i] = self[0][i] * other[0] + 
                    self[1][i] * other[1] + 
                    self[2][i] * other[2];
        }
        return Vector3d{
            x: data[0],
            y: data[1],
            z: data[2]
        }
    }
}
impl&lt;T: Scalar&gt; Mul&lt;Vector3d&lt;T&gt;&gt; for &amp;Transform&lt;T&gt; {
    type Output = Vector3d&lt;T&gt;;
    fn mul(self, rhs: Vector3d&lt;T&gt;) -&gt; Vector3d&lt;T&gt; {
        return self.m * rhs;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This means that the transform can be applied to a vector as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let t = Transform::scale(2.0, 3.0, 4.0);
    let v = Vector3d::new(1.0, 2.0, 3.0);
    let expected = Vector3d::new(2.0, 6.0, 12.0);
    assert_eq!(&amp;t * v, expected);
<span class="boring">}
</span></code></pre></pre>
<h2 id="applying-the-transformations"><a class="header" href="#applying-the-transformations">Applying the transformations</a></h2>
<p>The <code>Mul</code> operator is implemented for the following types:</p>
<h3 id="point3d"><a class="header" href="#point3d"><code>Point3d</code></a></h3>
<p>We perform matrix multiplication with the the point and transformation matrix. By including the third column of the matrix we implicitly capture the \(w\) value of the homogeneous representation of our point. We then convert from the homogeneous representation back to nonhomogeneous by dividing by \(w\). This division is skipped if we know the \(w\) value is one.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Mul&lt;Point3d&lt;T&gt;&gt; for Matrix4x4&lt;T&gt; {
    type Output = Point3d&lt;T&gt;;
    fn mul(self, other: Point3d&lt;T&gt;) -&gt; Point3d&lt;T&gt; {
        let x = other.x;
        let y = other.y;
        let z = other.z;
        let xp = self[0][0] * x + self[0][1] * y + self[0][2] * z + self[0][3];
        let yp = self[1][0] * x + self[1][1] * y + self[1][2] * z + self[1][3];
        let zp = self[2][0] * x + self[2][1] * y + self[2][2] * z + self[2][3];
        let wp = self[3][0] * x + self[3][1] * y + self[3][2] * z + self[3][3];
        if wp == T::one(){
            return Point3d{
                x: xp,
                y: yp,
                z: zp
            }
        } else{
            return Point3d{
                x: xp / wp,
                y: yp / wp,
                z: zp / wp
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="vector3d"><a class="header" href="#vector3d"><code>Vector3d</code></a></h3>
<p>This works the same way as the <code>Point3d</code>, but we can skip adding a term for the third column of the matrix, as we know \(w\) is 0.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Mul&lt;Vector3d&lt;T&gt;&gt; for Matrix4x4&lt;T&gt; {
    type Output = Vector3d&lt;T&gt;;
    fn mul(self, other: Vector3d&lt;T&gt;) -&gt; Vector3d&lt;T&gt; {
        let x = other.x;
        let y = other.y;
        let z = other.z;
        return Vector3d{
            x: x * self[0][0] + y * self[1][0] + z * self[2][0],
            y: x * self[0][1] + y * self[1][1] + z * self[2][1],
            z: x * self[0][2] + y * self[1][2] + z * self[2][2],
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="normal3d"><a class="header" href="#normal3d"><code>Normal3d</code></a></h3>
<p>It turns out that surface normals can't be transformed as straightforwardly as vectors and points, because non-uniform scaling can result in the normal being non-perpendicular. Figure 10 shows this:</p>
<p align="center">
    <img src="images/transform_normal.svg" style="background-color: white" width="400">
</p>
<p><em>Figure 10: Transforming surface normals. (a) is the original circle, with the normal at a point represented by the arrow. (b) shows what happens when the circle is scaled to be half as tall in the \(y\) direction -- if we just treat the normal as a vector, it will no longer be perpendicular to the surface. (c) shows the desired outcome -- after scaling, the normal should remain perpendicular to the surface.</em></p>
<p>To find the transform for a normal vector given the transform matrix for a point, we can use the inverse of the transpose of the transformation matrix. The intuition for this is that:</p>
<ul>
<li>
<p>We want this matrix to preserve the rotations of the point being transformed. The inverse transpose meets this need because the transpose of the inverse of a rotation matrix is the same rotation matrix.</p>
</li>
<li>
<p>We want the scaling applied to the normal to be <em>proportionally inverse</em> to the scaling of the point being transformed. To vizualize this, consider what happens if we stretch a sphere out to be twice as long in the X axis as it is on the Y and Z axes. The surface of the shape is now twice as large, so the curvature is half of what it used to be. The inverse transpose satisfies this requirement because it will invert the scaling factor.</p>
</li>
</ul>
<p>The implementation looks like this (note the indices, which result in the transpose of the inverse):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Mul&lt;Normal3d&lt;T&gt;&gt; for &amp;Transform&lt;T&gt; {
    type Output = Normal3d&lt;T&gt;;
    fn mul(self, rhs: Normal3d&lt;T&gt;) -&gt; Normal3d&lt;T&gt; {
        let x = rhs.x;
        let y = rhs.y;
        let z = rhs.z;
        return Normal3d::new(
            self.m_inv.data[0][0] * x + self.m_inv.data[1][0] * y + self.m_inv.data[2][0] * z,
            self.m_inv.data[0][1] * x + self.m_inv.data[1][1] * y + self.m_inv.data[2][1] * z,
            self.m_inv.data[0][2] * x + self.m_inv.data[1][2] * y + self.m_inv.data[2][2] * z,
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="ray"><a class="header" href="#ray"><code>Ray</code></a></h3>
<p>For rays, we just transform the origin and direction, and copy the remaining data members:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Mul&lt;Ray&lt;T&gt;&gt; for &amp;Transform&lt;T&gt; {
    type Output = Ray&lt;T&gt;;
    fn mul(self, rhs: Ray&lt;T&gt;) -&gt; Ray&lt;T&gt; {
        return Ray{
            origin: self * rhs.origin,
            direction: self * rhs.direction,
            t_max: rhs.t_max,
            time: rhs.time
        };
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="bounds3d"><a class="header" href="#bounds3d"><code>Bounds3d</code></a></h3>
<p>For bounds, we transform the bounding points and construct a new <code>Bounds3d</code> from them:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Mul&lt;Bounds3d&lt;T&gt;&gt; for &amp;Transform&lt;T&gt; {
    type Output = Bounds3d&lt;T&gt;;
    fn mul(self, rhs: Bounds3d&lt;T&gt;) -&gt; Bounds3d&lt;T&gt; {
        let p_min = self * rhs.min;
        let p_max = self * rhs.max;
        return Bounds3d::new(p_min, p_max);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="transform"><a class="header" href="#transform"><code>Transform</code></a></h3>
<p>We additionally allow transforms to be composed, by multiplying them together.
To do this, we just multiply their matricies and inverses:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Scalar&gt; Mul&lt;Transform&lt;T&gt;&gt; for &amp;Transform&lt;T&gt; {
    type Output = Transform&lt;T&gt;;
    fn mul(self, rhs: Transform&lt;T&gt;) -&gt; Transform&lt;T&gt; {
        return Transform{m: self.m * rhs.m, m_inv: rhs.m_inv * self.m_inv};
    }
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
